#@ LogService log
#@ FormatService fs
#@ File(label="Choose .stg file") stgFile
#@ Boolean(label="Override calibration value?") override
#@ Double(label="New pixel size") pixelSize

import org.scijava.io.location.FileLocation

TILE_CONFIG_HEADER = /# Tile Configuration generated by Groovy script
dim = 3
multiseries = true

# Image coordinates
/

try {
	assert stgFile.name.endsWith('.stg')
	main()
} catch (AssertionError e) {
	log.error("Only .stg files are allowed.\n" + e.getMessage())
}

def main() {
	// Get parent folder and basename
	def folder = stgFile.getParentFile()
	def basename = stgFile.getName()
	basename = basename.substring(0, basename.indexOf('.stg'))

	// TODO optionally look for connected groups of tiles and separate them

	// List all nd files that start with basename
	p = ~(/.*\Q/ + basename + /\E[^\\]*\.nd/)
	folder.eachFileMatch(p) {
		writeTileConfigFromDataset(folder, stgFile, it, basename)
	}
}

def parseMetadata(ndPath) {
	fileLocation = new FileLocation(ndPath)
	def format = fs.getFormat(fileLocation)
	def metadata = format.createParser().parse(fileLocation).get(0)
	def dims = [] // TODO also get total size Z, return map
	metadata.getAxes().each { axis ->
		dims << axis.averageScale(0,1)
	}
	dims
}

def writeTileConfigFromDataset(dir, stg, nd, base) {
	// Get metadata from nd file
	def (sizeX, sizeY, sizeZ) = parseMetadata(nd.getPath())
	if (override) {
		sizeX = pixelSize
		sizeY = pixelSize
	}

	// Parse stg file
	// TODO instead of matching a pattern, always start from line 5 and consider all entries
	linePattern = ~/"Position(\d+)", ([-\.0-9]+), ([-\.0-9]+),.*/
	def pos = []
	def xPos = []
	def yPos = []
	stg.eachLine {
		def m = linePattern.matcher(it)
		if (m.matches()) {
			pos << (m.group(1) as Integer)
			xPos << (m.group(2) as Double)
			yPos << (m.group(3) as Double)
		}
	}

	// Write TileConfiguration.txt file
	def tcFile = new File(dir, base + "stgTileConfiguration.txt")
	tcFile.withWriter { writer ->
		writer.write(TILE_CONFIG_HEADER)
		[pos, xPos, yPos].transpose().collect {
			def line = nd.getName() + "; " + (it[0]-1) + "; " + "( " + (it[1]/sizeX) + ", " + (it[2]/sizeY) + ", 0)"
			writer.write(line)
			writer.newLine()
		}
	}
	log.info("Finished writing " + tcFile.getName())
}
